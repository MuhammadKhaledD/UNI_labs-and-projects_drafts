#include <iostream>
using namespace std;

#include "Employee.h"

int main()
{
    Employee programmer("Ahmed",22);

	// However, the object manager will be constructed in the next line,
	// the usual Empolyee constructor is NOT called here. Why?

	Employee manager = programmer; // Note: the declaration and initialization are in the same line

	// In the previous statement, the "Copy Constructor" is called (not the normal constructor)
	// Read the lab document to know when the copy constructor is called in general.

	// What is copy constructor??
	// Copy constructor is a constructor that takes "another object of the same class" [by reference]
	
	// If you don't define a copy constructor, the compiler generates one by default for you
	// The COPY constructor of the compiler: 
	// constructs a new object of the class and copies its data members from the data members of the passed object

	// it performs a "Shallow Copying" --> shallow means making a blind member-wise assignment
	// for example,
	// data_member_1 of the the newly constructed object = data_member_1 of the passed object
	// data_member_2 of the the newly constructed object = data_member_2 of the passed object
	// and so on ...
	// This is what the default COPY constructor generated by the compiler does.

	// If you want to provide another behavior to be executed when the copy constructor is called
	// you should define a copy constructor with the behavior you want
	// Note: the compiler generates its copy constructor only if you don't provide a copy constructor

	// The previous statement:  Employee manager = programmer;   calls the copy constructor
	// the compiler's copy constructor assigns each member in "manager" to its corresponding member in "programmer"
	
	// Q: What a bout pointer mambers (like char* name here)	
	// For "name", the two objects (manager and programmer) will reference (point to) the same allocated array of name
	// When the second object "manager" is destructed this array is deallocated (we deleted it in the destructor)
	// This leaves pointer programmer::name pointing to a deleted memory

	// Q: What happens when "programmer" destructor tries to delete name again?
	// Runtime Error ... 

	// Don't put system pause or cin here to be able to see the error

	// After the first run and seeing the error,
	// uncomment the copy constructor defined inside class Employee and re-run
	// the problem is solved. Why??
 
	return 0;
} 